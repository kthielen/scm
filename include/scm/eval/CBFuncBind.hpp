
#ifndef EVAL_CBFUNCBIND_H_INCLUDED
#define EVAL_CBFUNCBIND_H_INCLUDED

/*
    CBFuncBind.hpp - A C/C++ function binding utility generated by tools/scm/CBFuncUtil.ssp
*/

#include <scm/eval/Allocator.hpp>
#include <scm/eval/Util.hpp>
#include <scm/eval/CTypeUtil.hpp>
#include <iostream>
#include <sstream>

namespace scm {

template < typename R >
    class CBFn0
    {
    public:
        CBFn0(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            
        }

        R apply() {
            if (!this->fn) return R();

            Value* rv = this->fn->Invoke(0, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()() {
            if (!this->fn) return R();

            Value* rv = this->fn->Invoke(0, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

    };

template <  >
    class CBFn0<void>
    {
    public:
        CBFn0(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            
        }

        void apply() {
            if (!this->fn) return ;

            this->fn->Invoke(0, this->env);
            return ;
        }

        void operator()() {
            if (!this->fn) return ;

            this->fn->Invoke(0, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

    };

template < typename R, typename A0 >
    class CBFn1
    {
    public:
        CBFn1(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), (Value*)0);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
    };

template < typename A0 >
    class CBFn1<void, A0>
    {
    public:
        CBFn1(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), (Value*)0);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
    };

template < typename R, typename A0, typename A1 >
    class CBFn2
    {
    public:
        CBFn2(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), (Value*)0);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
    };

template < typename A0, typename A1 >
    class CBFn2<void, A0, A1>
    {
    public:
        CBFn2(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), (Value*)0);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
    };

template < typename R, typename A0, typename A1, typename A2 >
    class CBFn3
    {
    public:
        CBFn3(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), (Value*)0);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
    };

template < typename A0, typename A1, typename A2 >
    class CBFn3<void, A0, A1, A2>
    {
    public:
        CBFn3(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), (Value*)0);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3 >
    class CBFn4
    {
    public:
        CBFn4(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), (Value*)0);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
    };

template < typename A0, typename A1, typename A2, typename A3 >
    class CBFn4<void, A0, A1, A2, A3>
    {
    public:
        CBFn4(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), (Value*)0);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class CBFn5
    {
    public:
        CBFn5(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), (Value*)0);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4 >
    class CBFn5<void, A0, A1, A2, A3, A4>
    {
    public:
        CBFn5(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), (Value*)0);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class CBFn6
    {
    public:
        CBFn6(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), (Value*)0);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class CBFn6<void, A0, A1, A2, A3, A4, A5>
    {
    public:
        CBFn6(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), (Value*)0);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class CBFn7
    {
    public:
        CBFn7(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), (Value*)0);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class CBFn7<void, A0, A1, A2, A3, A4, A5, A6>
    {
    public:
        CBFn7(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), (Value*)0);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class CBFn8
    {
    public:
        CBFn8(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), (Value*)0);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class CBFn8<void, A0, A1, A2, A3, A4, A5, A6, A7>
    {
    public:
        CBFn8(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), (Value*)0);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class CBFn9
    {
    public:
        CBFn9(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), (Value*)0);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class CBFn9<void, A0, A1, A2, A3, A4, A5, A6, A7, A8>
    {
    public:
        CBFn9(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), (Value*)0);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class CBFn10
    {
    public:
        CBFn10(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), (Value*)0);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class CBFn10<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>
    {
    public:
        CBFn10(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), (Value*)0);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class CBFn11
    {
    public:
        CBFn11(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), (Value*)0);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class CBFn11<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>
    {
    public:
        CBFn11(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), (Value*)0);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class CBFn12
    {
    public:
        CBFn12(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            this->a11n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a11n = a->template allocate<ConsPair>(CToLisp<A11>::alloc(a, A11()), (Value*)0);
                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), this->a11n);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
        ConsPair* a11n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class CBFn12<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>
    {
    public:
        CBFn12(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            this->a11n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a11n = a->template allocate<ConsPair>(CToLisp<A11>::alloc(a, A11()), (Value*)0);
                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), this->a11n);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
        ConsPair* a11n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class CBFn13
    {
    public:
        CBFn13(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            this->a11n = 0;
            this->a12n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a12n = a->template allocate<ConsPair>(CToLisp<A12>::alloc(a, A12()), (Value*)0);
                this->a11n = a->template allocate<ConsPair>(CToLisp<A11>::alloc(a, A11()), this->a12n);
                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), this->a11n);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
        ConsPair* a11n;
        ConsPair* a12n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class CBFn13<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>
    {
    public:
        CBFn13(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            this->a11n = 0;
            this->a12n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a12n = a->template allocate<ConsPair>(CToLisp<A12>::alloc(a, A12()), (Value*)0);
                this->a11n = a->template allocate<ConsPair>(CToLisp<A11>::alloc(a, A11()), this->a12n);
                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), this->a11n);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
        ConsPair* a11n;
        ConsPair* a12n;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class CBFn14
    {
    public:
        CBFn14(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            this->a11n = 0;
            this->a12n = 0;
            this->a13n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a13n = a->template allocate<ConsPair>(CToLisp<A13>::alloc(a, A13()), (Value*)0);
                this->a12n = a->template allocate<ConsPair>(CToLisp<A12>::alloc(a, A12()), this->a13n);
                this->a11n = a->template allocate<ConsPair>(CToLisp<A11>::alloc(a, A11()), this->a12n);
                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), this->a11n);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        R apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12, const A13& a13) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            CToLisp<A13>::argSet(this->a13n, a13);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }

        R operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12, const A13& a13) {
            if (!this->fn) return R();

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            CToLisp<A13>::argSet(this->a13n, a13);
            Value* rv = this->fn->Invoke(this->a0n, this->env);
            return LispToC<R>::unbox(rv);
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
        ConsPair* a11n;
        ConsPair* a12n;
        ConsPair* a13n;
    };

template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class CBFn14<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>
    {
    public:
        CBFn14(EnvironmentFrame* env, Function* fn = 0) : env(env) {

            this->a0n = 0;
            this->a1n = 0;
            this->a2n = 0;
            this->a3n = 0;
            this->a4n = 0;
            this->a5n = 0;
            this->a6n = 0;
            this->a7n = 0;
            this->a8n = 0;
            this->a9n = 0;
            this->a10n = 0;
            this->a11n = 0;
            this->a12n = 0;
            this->a13n = 0;
            function(fn);
        }

		Function* function() {
            return this->fn;
        }

        void function(Function* f) {
            this->fn = f;

            if (this->fn && !this->a0n) {
                Allocator* a = this->fn->allocator();

                this->a13n = a->template allocate<ConsPair>(CToLisp<A13>::alloc(a, A13()), (Value*)0);
                this->a12n = a->template allocate<ConsPair>(CToLisp<A12>::alloc(a, A12()), this->a13n);
                this->a11n = a->template allocate<ConsPair>(CToLisp<A11>::alloc(a, A11()), this->a12n);
                this->a10n = a->template allocate<ConsPair>(CToLisp<A10>::alloc(a, A10()), this->a11n);
                this->a9n = a->template allocate<ConsPair>(CToLisp<A9>::alloc(a, A9()), this->a10n);
                this->a8n = a->template allocate<ConsPair>(CToLisp<A8>::alloc(a, A8()), this->a9n);
                this->a7n = a->template allocate<ConsPair>(CToLisp<A7>::alloc(a, A7()), this->a8n);
                this->a6n = a->template allocate<ConsPair>(CToLisp<A6>::alloc(a, A6()), this->a7n);
                this->a5n = a->template allocate<ConsPair>(CToLisp<A5>::alloc(a, A5()), this->a6n);
                this->a4n = a->template allocate<ConsPair>(CToLisp<A4>::alloc(a, A4()), this->a5n);
                this->a3n = a->template allocate<ConsPair>(CToLisp<A3>::alloc(a, A3()), this->a4n);
                this->a2n = a->template allocate<ConsPair>(CToLisp<A2>::alloc(a, A2()), this->a3n);
                this->a1n = a->template allocate<ConsPair>(CToLisp<A1>::alloc(a, A1()), this->a2n);
                this->a0n = a->template allocate<ConsPair>(CToLisp<A0>::alloc(a, A0()), this->a1n);
            }
        }

        void references(AllocVisitor& v) {
            v.visit((AllocBase*&)this->env);
            v.visit((AllocBase*&)this->fn);
            v.visit((AllocBase*&)this->a0n);
        }

        void apply(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12, const A13& a13) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            CToLisp<A13>::argSet(this->a13n, a13);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }

        void operator()(const A0& a0, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12, const A13& a13) {
            if (!this->fn) return ;

            CToLisp<A0>::argSet(this->a0n, a0);
            CToLisp<A1>::argSet(this->a1n, a1);
            CToLisp<A2>::argSet(this->a2n, a2);
            CToLisp<A3>::argSet(this->a3n, a3);
            CToLisp<A4>::argSet(this->a4n, a4);
            CToLisp<A5>::argSet(this->a5n, a5);
            CToLisp<A6>::argSet(this->a6n, a6);
            CToLisp<A7>::argSet(this->a7n, a7);
            CToLisp<A8>::argSet(this->a8n, a8);
            CToLisp<A9>::argSet(this->a9n, a9);
            CToLisp<A10>::argSet(this->a10n, a10);
            CToLisp<A11>::argSet(this->a11n, a11);
            CToLisp<A12>::argSet(this->a12n, a12);
            CToLisp<A13>::argSet(this->a13n, a13);
            this->fn->Invoke(this->a0n, this->env);
            return ;
        }
    private:
        EnvironmentFrame* env;
        Function*         fn;

        ConsPair* a0n;
        ConsPair* a1n;
        ConsPair* a2n;
        ConsPair* a3n;
        ConsPair* a4n;
        ConsPair* a5n;
        ConsPair* a6n;
        ConsPair* a7n;
        ConsPair* a8n;
        ConsPair* a9n;
        ConsPair* a10n;
        ConsPair* a11n;
        ConsPair* a12n;
        ConsPair* a13n;
    };

}
#endif
