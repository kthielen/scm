
#ifndef EVAL_CFUNCBIND_H_INCLUDED
#define EVAL_CFUNCBIND_H_INCLUDED

/*
    CFuncBind.hpp - A C/C++ function binding utility generated by eval/tools/scm/CFuncBind.ssp
*/

#include <scm/eval/Allocator.hpp>
#include <scm/eval/Util.hpp>
#include <scm/eval/CTypeUtil.hpp>
#include <iostream>
#include <sstream>

namespace scm {

template < typename R >
    class CFn0 : public Function
    {
    public:
        typedef R (*PFN)();

		typedef CToLisp<R> R2C;

        CFn0(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn0<R> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {

                R r = fn();
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R >
    Function* bindfn(Allocator* a, R (*pfn)())
    {
        typedef CFn0<R> FnObj;
        typedef R (*PFNT)();

        return a-> template allocate< FnObj >(pfn);
    }


template <  >
    class CFn0<void> : public Function
    {
    public:
        typedef void (*PFN)();


        CFn0(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->allocate< CFn0<void> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {

                fn();
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R >
    class OFn0 : public Function
    {
    public:
        typedef R (C::*PFN)();

		typedef CToLisp<R> R2C;

        OFn0(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn0<C, R> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {

                R r = (obj->*fn)();
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)())
    {
        typedef OFn0<C, R> FnObj;
        typedef R (C::*PFNT)();

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C >
    class OFn0<C, void> : public Function
    {
    public:
        typedef void (C::*PFN)();


        OFn0(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn0<C, void> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {

                (obj->*fn)();
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R >
    class MFn0 : public Function
    {
    public:
        typedef R (C::*PFN)();

		typedef CToLisp<R> R2C;
        typedef LispToC< C > CC; 

        MFn0(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn0<C, R> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);


                R r = ((&(CC::unpack(C_v)))->*fn)();
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R >
    Function* bindfn(Allocator* a, R (C::*pfn)())
    {
        typedef MFn0<C, R> FnObj;
        typedef R (C::*PFNT)();

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C >
    class MFn0<C, void> : public Function
    {
    public:
        typedef void (C::*PFN)();

        typedef LispToC< C > CC; 

        MFn0(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn0<C, void> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);


                ((&(CC::unpack(C_v)))->*fn)();
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R >
    class MCFn0 : public Function
    {
    public:
        typedef R (C::*PFN)() const;

		typedef CToLisp<R> R2C;
        typedef LispToC< C > CC; 

        MCFn0(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn0<C, R> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);


                R r = ((&(CC::unpack(C_v)))->*fn)();
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R >
    Function* bindfn(Allocator* a, R (C::*pfn)() const)
    {
        typedef MCFn0<C, R> FnObj;
        typedef R (C::*PFNT)();

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C >
    class MCFn0<C, void> : public Function
    {
    public:
        typedef void (C::*PFN)() const;

        typedef LispToC< C > CC; 

        MCFn0(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn0<C, void> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 0 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);


                ((&(CC::unpack(C_v)))->*fn)();
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0 >
    class CFn1 : public Function
    {
    public:
        typedef R (*PFN)(A0);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 

        CFn1(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn1<R, A0> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 

                R r = fn(A0C::unpack(a0_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0 >
    Function* bindfn(Allocator* a, R (*pfn)(A0))
    {
        typedef CFn1<R, A0> FnObj;
        typedef R (*PFNT)(A0);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0 >
    class CFn1<void, A0> : public Function
    {
    public:
        typedef void (*PFN)(A0);

        typedef LispToC< A0 > A0C; 

        CFn1(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn1<void, A0> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 

                fn(A0C::unpack(a0_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0 >
    class OFn1 : public Function
    {
    public:
        typedef R (C::*PFN)(A0);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 

        OFn1(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn1<C, R, A0> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0))
    {
        typedef OFn1<C, R, A0> FnObj;
        typedef R (C::*PFNT)(A0);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0 >
    class OFn1<C, void, A0> : public Function
    {
    public:
        typedef void (C::*PFN)(A0);

        typedef LispToC< A0 > A0C; 

        OFn1(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn1<C, void, A0> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 

                (obj->*fn)(A0C::unpack(a0_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0 >
    class MFn1 : public Function
    {
    public:
        typedef R (C::*PFN)(A0);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< C > CC; 

        MFn1(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn1<C, R, A0> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0))
    {
        typedef MFn1<C, R, A0> FnObj;
        typedef R (C::*PFNT)(A0);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0 >
    class MFn1<C, void, A0> : public Function
    {
    public:
        typedef void (C::*PFN)(A0);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< C > CC; 

        MFn1(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn1<C, void, A0> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0 >
    class MCFn1 : public Function
    {
    public:
        typedef R (C::*PFN)(A0) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< C > CC; 

        MCFn1(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn1<C, R, A0> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0) const)
    {
        typedef MCFn1<C, R, A0> FnObj;
        typedef R (C::*PFNT)(A0);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0 >
    class MCFn1<C, void, A0> : public Function
    {
    public:
        typedef void (C::*PFN)(A0) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< C > CC; 

        MCFn1(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn1<C, void, A0> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 1 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1 >
    class CFn2 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 

        CFn2(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn2<R, A0, A1> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1))
    {
        typedef CFn2<R, A0, A1> FnObj;
        typedef R (*PFNT)(A0, A1);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1 >
    class CFn2<void, A0, A1> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 

        CFn2(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn2<void, A0, A1> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1 >
    class OFn2 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 

        OFn2(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn2<C, R, A0, A1> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1))
    {
        typedef OFn2<C, R, A0, A1> FnObj;
        typedef R (C::*PFNT)(A0, A1);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1 >
    class OFn2<C, void, A0, A1> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 

        OFn2(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn2<C, void, A0, A1> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1 >
    class MFn2 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< C > CC; 

        MFn2(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn2<C, R, A0, A1> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1))
    {
        typedef MFn2<C, R, A0, A1> FnObj;
        typedef R (C::*PFNT)(A0, A1);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1 >
    class MFn2<C, void, A0, A1> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< C > CC; 

        MFn2(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn2<C, void, A0, A1> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1 >
    class MCFn2 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< C > CC; 

        MCFn2(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn2<C, R, A0, A1> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1) const)
    {
        typedef MCFn2<C, R, A0, A1> FnObj;
        typedef R (C::*PFNT)(A0, A1);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1 >
    class MCFn2<C, void, A0, A1> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< C > CC; 

        MCFn2(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn2<C, void, A0, A1> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 2 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2 >
    class CFn3 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 

        CFn3(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn3<R, A0, A1, A2> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2))
    {
        typedef CFn3<R, A0, A1, A2> FnObj;
        typedef R (*PFNT)(A0, A1, A2);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2 >
    class CFn3<void, A0, A1, A2> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 

        CFn3(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn3<void, A0, A1, A2> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2 >
    class OFn3 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 

        OFn3(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn3<C, R, A0, A1, A2> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2))
    {
        typedef OFn3<C, R, A0, A1, A2> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2 >
    class OFn3<C, void, A0, A1, A2> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 

        OFn3(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn3<C, void, A0, A1, A2> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2 >
    class MFn3 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< C > CC; 

        MFn3(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn3<C, R, A0, A1, A2> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2))
    {
        typedef MFn3<C, R, A0, A1, A2> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2 >
    class MFn3<C, void, A0, A1, A2> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< C > CC; 

        MFn3(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn3<C, void, A0, A1, A2> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2 >
    class MCFn3 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< C > CC; 

        MCFn3(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn3<C, R, A0, A1, A2> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2) const)
    {
        typedef MCFn3<C, R, A0, A1, A2> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2 >
    class MCFn3<C, void, A0, A1, A2> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< C > CC; 

        MCFn3(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn3<C, void, A0, A1, A2> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 3 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3 >
    class CFn4 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 

        CFn4(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn4<R, A0, A1, A2, A3> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3))
    {
        typedef CFn4<R, A0, A1, A2, A3> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3 >
    class CFn4<void, A0, A1, A2, A3> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 

        CFn4(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn4<void, A0, A1, A2, A3> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3 >
    class OFn4 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 

        OFn4(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn4<C, R, A0, A1, A2, A3> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3))
    {
        typedef OFn4<C, R, A0, A1, A2, A3> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3 >
    class OFn4<C, void, A0, A1, A2, A3> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 

        OFn4(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn4<C, void, A0, A1, A2, A3> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3 >
    class MFn4 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< C > CC; 

        MFn4(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn4<C, R, A0, A1, A2, A3> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3))
    {
        typedef MFn4<C, R, A0, A1, A2, A3> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3 >
    class MFn4<C, void, A0, A1, A2, A3> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< C > CC; 

        MFn4(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn4<C, void, A0, A1, A2, A3> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3 >
    class MCFn4 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< C > CC; 

        MCFn4(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn4<C, R, A0, A1, A2, A3> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3) const)
    {
        typedef MCFn4<C, R, A0, A1, A2, A3> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3 >
    class MCFn4<C, void, A0, A1, A2, A3> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< C > CC; 

        MCFn4(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn4<C, void, A0, A1, A2, A3> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 4 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class CFn5 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 

        CFn5(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn5<R, A0, A1, A2, A3, A4> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4))
    {
        typedef CFn5<R, A0, A1, A2, A3, A4> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4 >
    class CFn5<void, A0, A1, A2, A3, A4> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 

        CFn5(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn5<void, A0, A1, A2, A3, A4> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class OFn5 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 

        OFn5(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn5<C, R, A0, A1, A2, A3, A4> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4))
    {
        typedef OFn5<C, R, A0, A1, A2, A3, A4> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class OFn5<C, void, A0, A1, A2, A3, A4> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 

        OFn5(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn5<C, void, A0, A1, A2, A3, A4> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class MFn5 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< C > CC; 

        MFn5(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn5<C, R, A0, A1, A2, A3, A4> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4))
    {
        typedef MFn5<C, R, A0, A1, A2, A3, A4> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class MFn5<C, void, A0, A1, A2, A3, A4> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< C > CC; 

        MFn5(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn5<C, void, A0, A1, A2, A3, A4> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class MCFn5 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< C > CC; 

        MCFn5(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn5<C, R, A0, A1, A2, A3, A4> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4) const)
    {
        typedef MCFn5<C, R, A0, A1, A2, A3, A4> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4 >
    class MCFn5<C, void, A0, A1, A2, A3, A4> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< C > CC; 

        MCFn5(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn5<C, void, A0, A1, A2, A3, A4> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 5 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class CFn6 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 

        CFn6(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn6<R, A0, A1, A2, A3, A4, A5> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5))
    {
        typedef CFn6<R, A0, A1, A2, A3, A4, A5> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class CFn6<void, A0, A1, A2, A3, A4, A5> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 

        CFn6(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn6<void, A0, A1, A2, A3, A4, A5> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class OFn6 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 

        OFn6(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn6<C, R, A0, A1, A2, A3, A4, A5> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5))
    {
        typedef OFn6<C, R, A0, A1, A2, A3, A4, A5> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class OFn6<C, void, A0, A1, A2, A3, A4, A5> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 

        OFn6(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn6<C, void, A0, A1, A2, A3, A4, A5> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class MFn6 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< C > CC; 

        MFn6(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn6<C, R, A0, A1, A2, A3, A4, A5> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5))
    {
        typedef MFn6<C, R, A0, A1, A2, A3, A4, A5> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class MFn6<C, void, A0, A1, A2, A3, A4, A5> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< C > CC; 

        MFn6(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn6<C, void, A0, A1, A2, A3, A4, A5> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class MCFn6 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< C > CC; 

        MCFn6(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn6<C, R, A0, A1, A2, A3, A4, A5> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5) const)
    {
        typedef MCFn6<C, R, A0, A1, A2, A3, A4, A5> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5 >
    class MCFn6<C, void, A0, A1, A2, A3, A4, A5> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< C > CC; 

        MCFn6(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn6<C, void, A0, A1, A2, A3, A4, A5> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 6 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class CFn7 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 

        CFn7(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn7<R, A0, A1, A2, A3, A4, A5, A6> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6))
    {
        typedef CFn7<R, A0, A1, A2, A3, A4, A5, A6> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class CFn7<void, A0, A1, A2, A3, A4, A5, A6> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 

        CFn7(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn7<void, A0, A1, A2, A3, A4, A5, A6> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class OFn7 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 

        OFn7(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn7<C, R, A0, A1, A2, A3, A4, A5, A6> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6))
    {
        typedef OFn7<C, R, A0, A1, A2, A3, A4, A5, A6> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class OFn7<C, void, A0, A1, A2, A3, A4, A5, A6> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 

        OFn7(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn7<C, void, A0, A1, A2, A3, A4, A5, A6> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class MFn7 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< C > CC; 

        MFn7(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn7<C, R, A0, A1, A2, A3, A4, A5, A6> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6))
    {
        typedef MFn7<C, R, A0, A1, A2, A3, A4, A5, A6> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class MFn7<C, void, A0, A1, A2, A3, A4, A5, A6> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< C > CC; 

        MFn7(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn7<C, void, A0, A1, A2, A3, A4, A5, A6> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class MCFn7 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< C > CC; 

        MCFn7(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn7<C, R, A0, A1, A2, A3, A4, A5, A6> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6) const)
    {
        typedef MCFn7<C, R, A0, A1, A2, A3, A4, A5, A6> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 >
    class MCFn7<C, void, A0, A1, A2, A3, A4, A5, A6> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< C > CC; 

        MCFn7(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn7<C, void, A0, A1, A2, A3, A4, A5, A6> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 7 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class CFn8 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 

        CFn8(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn8<R, A0, A1, A2, A3, A4, A5, A6, A7> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7))
    {
        typedef CFn8<R, A0, A1, A2, A3, A4, A5, A6, A7> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class CFn8<void, A0, A1, A2, A3, A4, A5, A6, A7> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 

        CFn8(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn8<void, A0, A1, A2, A3, A4, A5, A6, A7> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class OFn8 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 

        OFn8(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn8<C, R, A0, A1, A2, A3, A4, A5, A6, A7> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7))
    {
        typedef OFn8<C, R, A0, A1, A2, A3, A4, A5, A6, A7> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class OFn8<C, void, A0, A1, A2, A3, A4, A5, A6, A7> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 

        OFn8(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn8<C, void, A0, A1, A2, A3, A4, A5, A6, A7> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class MFn8 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< C > CC; 

        MFn8(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn8<C, R, A0, A1, A2, A3, A4, A5, A6, A7> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7))
    {
        typedef MFn8<C, R, A0, A1, A2, A3, A4, A5, A6, A7> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class MFn8<C, void, A0, A1, A2, A3, A4, A5, A6, A7> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< C > CC; 

        MFn8(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn8<C, void, A0, A1, A2, A3, A4, A5, A6, A7> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class MCFn8 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< C > CC; 

        MCFn8(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn8<C, R, A0, A1, A2, A3, A4, A5, A6, A7> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7) const)
    {
        typedef MCFn8<C, R, A0, A1, A2, A3, A4, A5, A6, A7> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7 >
    class MCFn8<C, void, A0, A1, A2, A3, A4, A5, A6, A7> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< C > CC; 

        MCFn8(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn8<C, void, A0, A1, A2, A3, A4, A5, A6, A7> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 8 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class CFn9 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 

        CFn9(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn9<R, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
    {
        typedef CFn9<R, A0, A1, A2, A3, A4, A5, A6, A7, A8> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class CFn9<void, A0, A1, A2, A3, A4, A5, A6, A7, A8> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 

        CFn9(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn9<void, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class OFn9 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 

        OFn9(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn9<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
    {
        typedef OFn9<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class OFn9<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 

        OFn9(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn9<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class MFn9 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< C > CC; 

        MFn9(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn9<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
    {
        typedef MFn9<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class MFn9<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< C > CC; 

        MFn9(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn9<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class MCFn9 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< C > CC; 

        MCFn9(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn9<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
    {
        typedef MCFn9<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8 >
    class MCFn9<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< C > CC; 

        MCFn9(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn9<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 9 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class CFn10 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 

        CFn10(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn10<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
    {
        typedef CFn10<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class CFn10<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 

        CFn10(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn10<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class OFn10 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 

        OFn10(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn10<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
    {
        typedef OFn10<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class OFn10<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 

        OFn10(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn10<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class MFn10 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< C > CC; 

        MFn10(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn10<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
    {
        typedef MFn10<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class MFn10<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< C > CC; 

        MFn10(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn10<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class MCFn10 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< C > CC; 

        MCFn10(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn10<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
    {
        typedef MCFn10<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9 >
    class MCFn10<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< C > CC; 

        MCFn10(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn10<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 10 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class CFn11 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 

        CFn11(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn11<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
    {
        typedef CFn11<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class CFn11<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 

        CFn11(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn11<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class OFn11 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 

        OFn11(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn11<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
    {
        typedef OFn11<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class OFn11<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 

        OFn11(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn11<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class MFn11 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< C > CC; 

        MFn11(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn11<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
    {
        typedef MFn11<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class MFn11<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< C > CC; 

        MFn11(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn11<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class MCFn11 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< C > CC; 

        MCFn11(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn11<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
    {
        typedef MCFn11<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10 >
    class MCFn11<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< C > CC; 

        MCFn11(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn11<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 11 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class CFn12 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 

        CFn12(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn12<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
    {
        typedef CFn12<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class CFn12<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 

        CFn12(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn12<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class OFn12 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 

        OFn12(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn12<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
    {
        typedef OFn12<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class OFn12<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 

        OFn12(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn12<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class MFn12 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< C > CC; 

        MFn12(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn12<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
    {
        typedef MFn12<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class MFn12<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< C > CC; 

        MFn12(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn12<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class MCFn12 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< C > CC; 

        MCFn12(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn12<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
    {
        typedef MCFn12<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11 >
    class MCFn12<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< C > CC; 

        MCFn12(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn12<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 12 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class CFn13 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 

        CFn13(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn13<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
    {
        typedef CFn13<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class CFn13<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 

        CFn13(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn13<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class OFn13 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 

        OFn13(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn13<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
    {
        typedef OFn13<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class OFn13<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 

        OFn13(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn13<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class MFn13 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< C > CC; 

        MFn13(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn13<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
    {
        typedef MFn13<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class MFn13<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< C > CC; 

        MFn13(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn13<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class MCFn13 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< C > CC; 

        MCFn13(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn13<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
    {
        typedef MCFn13<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12 >
    class MCFn13<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< C > CC; 

        MCFn13(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn13<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 13 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class CFn14 : public Function
    {
    public:
        typedef R (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 

        CFn14(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn14<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 13, env); 

                R r = fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    Function* bindfn(Allocator* a, R (*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
    {
        typedef CFn14<R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> FnObj;
        typedef R (*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class CFn14<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> : public Function
    {
    public:
        typedef void (*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 

        CFn14(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< CFn14<void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 13, env); 

                fn(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class OFn14 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 

        OFn14(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn14<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 13, env); 

                R r = (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    Function* bindfn(Allocator* a, C* o, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
    {
        typedef OFn14<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        return a-> template allocate< FnObj >(o, pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class OFn14<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 

        OFn14(C* o, PFN pf, ConsPair* ca = 0) : obj(o), fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 0;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< OFn14<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(obj, fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 0, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 1, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 2, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 3, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 4, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 5, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 6, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 7, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 8, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 9, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 10, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 11, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 12, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 13, env); 

                (obj->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        C* obj;

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class MFn14 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 
        typedef LispToC< C > CC; 

        MFn14(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn14<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 14, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
    {
        typedef MFn14<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class MFn14<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 
        typedef LispToC< C > CC; 

        MFn14(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MFn14<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 14, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class MCFn14 : public Function
    {
    public:
        typedef R (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;

		typedef CToLisp<R> R2C;
        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 
        typedef LispToC< C > CC; 

        MCFn14(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn14<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 14, env); 

                R r = ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return R2C::alloc(allocator(), r);
            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };

template < typename C, typename R, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    Function* bindfn(Allocator* a, R (C::*pfn)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
    {
        typedef MCFn14<C, R, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> FnObj;
        typedef R (C::*PFNT)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

        return a-> template allocate< FnObj >(pfn);
    }


template < typename C, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13 >
    class MCFn14<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> : public Function
    {
    public:
        typedef void (C::*PFN)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;

        typedef LispToC< A0 > A0C; 
        typedef LispToC< A1 > A1C; 
        typedef LispToC< A2 > A2C; 
        typedef LispToC< A3 > A3C; 
        typedef LispToC< A4 > A4C; 
        typedef LispToC< A5 > A5C; 
        typedef LispToC< A6 > A6C; 
        typedef LispToC< A7 > A7C; 
        typedef LispToC< A8 > A8C; 
        typedef LispToC< A9 > A9C; 
        typedef LispToC< A10 > A10C; 
        typedef LispToC< A11 > A11C; 
        typedef LispToC< A12 > A12C; 
        typedef LispToC< A13 > A13C; 
        typedef LispToC< C > CC; 

        MCFn14(PFN pf, ConsPair* ca = 0) : fn(pf), cargs(ca), tvargs(0) { }

        Value* Invoke(ConsPair* args, EnvironmentFrame* env)
        {
            ConsPair*        vargs       = Append(this->cargs, args);
            static const int req_length  = ArgContrib<A0>::V + ArgContrib<A1>::V + ArgContrib<A2>::V + ArgContrib<A3>::V + ArgContrib<A4>::V + ArgContrib<A5>::V + ArgContrib<A6>::V + ArgContrib<A7>::V + ArgContrib<A8>::V + ArgContrib<A9>::V + ArgContrib<A10>::V + ArgContrib<A11>::V + ArgContrib<A12>::V + ArgContrib<A13>::V + 1;
            int              varg_length = Length(vargs);

            if (varg_length < req_length && req_length > 0)
                return env->allocator()->template allocate< MCFn14<C, void, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> >(fn, vargs);
            else if (varg_length > req_length && req_length > 0)
                throw std::runtime_error("Expected 14 arguments but received " + str::to_string(varg_length) + ".");

            this->tvargs = vargs;

            try
            {
                typename CC::PrimT C_v = CC::evaluate(vargs, 0, env);

                typename A0C::PrimT a0_v = A0C::evaluate(vargs, 1, env); 
                typename A1C::PrimT a1_v = A1C::evaluate(vargs, 2, env); 
                typename A2C::PrimT a2_v = A2C::evaluate(vargs, 3, env); 
                typename A3C::PrimT a3_v = A3C::evaluate(vargs, 4, env); 
                typename A4C::PrimT a4_v = A4C::evaluate(vargs, 5, env); 
                typename A5C::PrimT a5_v = A5C::evaluate(vargs, 6, env); 
                typename A6C::PrimT a6_v = A6C::evaluate(vargs, 7, env); 
                typename A7C::PrimT a7_v = A7C::evaluate(vargs, 8, env); 
                typename A8C::PrimT a8_v = A8C::evaluate(vargs, 9, env); 
                typename A9C::PrimT a9_v = A9C::evaluate(vargs, 10, env); 
                typename A10C::PrimT a10_v = A10C::evaluate(vargs, 11, env); 
                typename A11C::PrimT a11_v = A11C::evaluate(vargs, 12, env); 
                typename A12C::PrimT a12_v = A12C::evaluate(vargs, 13, env); 
                typename A13C::PrimT a13_v = A13C::evaluate(vargs, 14, env); 

                ((&(CC::unpack(C_v)))->*fn)(A0C::unpack(a0_v), A1C::unpack(a1_v), A2C::unpack(a2_v), A3C::unpack(a3_v), A4C::unpack(a4_v), A5C::unpack(a5_v), A6C::unpack(a6_v), A7C::unpack(a7_v), A8C::unpack(a8_v), A9C::unpack(a9_v), A10C::unpack(a10_v), A11C::unpack(a11_v), A12C::unpack(a12_v), A13C::unpack(a13_v));
                this->tvargs = 0;

                return 0;

            }
            catch (...)
            {
                this->tvargs = 0;
                throw;
            }
        }

        void references(AllocVisitor& v)
        {
            v.visit((AllocBase*&)cargs);
            v.visit((AllocBase*&)tvargs);
        }
    private:

        PFN       fn;
        ConsPair* cargs;
        ConsPair* tvargs;
    };


}
#endif
